<gamenight_common_patterns>
  <overview>
    Reusable patterns, templates, and examples specific to Game Night Central development.
    These patterns ensure consistency and accelerate development across the application.
  </overview>

  <api_patterns>
    <pattern name="api_route_structure">
      <description>Standard Next.js API route implementation</description>
      <template>
        <code language="typescript">
          // app/api/events/route.ts
          import { NextRequest, NextResponse } from 'next/server';
          import { prisma } from '@/lib/prisma';
          import { z } from 'zod';

          const CreateEventSchema = z.object({
            title: z.string().min(1).max(100),
            description: z.string().max(500),
            date: z.string().datetime(),
            location: z.string().min(1),
            maxParticipants: z.number().min(1).max(100)
          });

          export async function GET(request: NextRequest) {
            try {
              const { searchParams } = new URL(request.url);
              const page = parseInt(searchParams.get('page') || '1');
              const limit = parseInt(searchParams.get('limit') || '10');
              const skip = (page - 1) * limit;

              const [events, total] = await Promise.all([
                prisma.event.findMany({
                  skip,
                  take: limit,
                  orderBy: { date: 'asc' },
                  include: { organizer: true, participants: true }
                }),
                prisma.event.count()
              ]);

              return NextResponse.json({
                events,
                pagination: {
                  page,
                  limit,
                  total,
                  pages: Math.ceil(total / limit)
                }
              });
            } catch (error) {
              console.error('Error fetching events:', error);
              return NextResponse.json(
                { error: 'Failed to fetch events' },
                { status: 500 }
              );
            }
          }

          export async function POST(request: NextRequest) {
            try {
              const body = await request.json();
              const validatedData = CreateEventSchema.parse(body);

              // Check authentication
              const userId = request.headers.get('x-user-id');
              if (!userId) {
                return NextResponse.json(
                  { error: 'Unauthorized' },
                  { status: 401 }
                );
              }

              const event = await prisma.event.create({
                data: {
                  ...validatedData,
                  organizerId: userId
                },
                include: { organizer: true }
              });

              return NextResponse.json(event, { status: 201 });
            } catch (error) {
              if (error instanceof z.ZodError) {
                return NextResponse.json(
                  { error: 'Invalid input', details: error.errors },
                  { status: 400 }
                );
              }

              console.error('Error creating event:', error);
              return NextResponse.json(
                { error: 'Failed to create event' },
                { status: 500 }
              );
            }
          }
        </code>
      </template>
    </pattern>

    <pattern name="authenticated_api_route">
      <description>API route with authentication middleware</description>
      <template>
        <code language="typescript">
          // lib/auth.ts
          import { NextRequest } from 'next/server';
          import { prisma } from '@/lib/prisma';

          export async function getAuthenticatedUser(request: NextRequest) {
            const userId = request.headers.get('x-user-id');
            if (!userId) {
              throw new Error('Unauthorized');
            }

            const user = await prisma.user.findUnique({
              where: { id: userId }
            });

            if (!user) {
              throw new Error('User not found');
            }

            return user;
          }

          export async function requireRole(request: NextRequest, allowedRoles: string[]) {
            const user = await getAuthenticatedUser(request);

            if (!allowedRoles.includes(user.role)) {
              throw new Error('Insufficient permissions');
            }

            return user;
          }

          // Usage in API route
          export async function DELETE(
            request: NextRequest,
            { params }: { params: { id: string } }
          ) {
            try {
              const user = await requireRole(request, ['admin', 'organizer']);

              const event = await prisma.event.findFirst({
                where: { id: params.id, organizerId: user.id }
              });

              if (!event) {
                return NextResponse.json(
                  { error: 'Event not found or access denied' },
                  { status: 404 }
                );
              }

              await prisma.event.delete({
                where: { id: params.id }
              });

              return NextResponse.json({ success: true });
            } catch (error) {
              if (error instanceof Error) {
                if (error.message === 'Unauthorized' || error.message === 'Insufficient permissions') {
                  return NextResponse.json(
                    { error: error.message },
                    { status: 403 }
                  );
                }
              }

              return NextResponse.json(
                { error: 'Internal server error' },
                { status: 500 }
              );
            }
          }
        </code>
      </template>
    </pattern>
  </api_patterns>

  <database_patterns>
    <pattern name="prisma_migration">
      <description>Database migration with proper rollback strategy</description>
      <steps>
        <step>Create migration file with npx prisma migrate dev --name feature-name</step>
        <step>Test migration on development database</step>
        <step>Update TypeScript types with npx prisma generate</step>
        <step>Create seed data if needed</step>
        <step>Test on staging environment</step>
      </steps>
      <template>
        <code language="sql">
          -- Migration: Add user preferences
          -- CreateEnum
          CREATE TYPE "NotificationPreference" AS ENUM ('ALL', 'IMPORTANT', 'NONE');

          -- AlterTable
          ALTER TABLE "User" ADD COLUMN     "notificationPreference" "NotificationPreference" NOT NULL DEFAULT 'ALL';
          ALTER TABLE "User" ADD COLUMN     "theme" TEXT NOT NULL DEFAULT 'light';

          -- CreateIndex
          CREATE INDEX "User_notificationPreference_idx" ON "User"("notificationPreference");
        </code>
      </template>
    </pattern>

    <pattern name="data_access_layer">
      <description>Repository pattern for data operations</description>
      <template>
        <code language="typescript">
          // lib/repositories/event-repository.ts
          import { prisma } from '@/lib/prisma';
          import { Event, Prisma } from '@prisma/client';

          export class EventRepository {
            static async findById(id: string): Promise<Event | null> {
              return prisma.event.findUnique({
                where: { id },
                include: { organizer: true, participants: true }
              });
            }

            static async findUpcoming(limit = 10): Promise<Event[]> {
              return prisma.event.findMany({
                where: {
                  date: { gte: new Date() }
                },
                orderBy: { date: 'asc' },
                take: limit,
                include: { organizer: true, participants: true }
              });
            }

            static async create(data: Prisma.EventCreateInput): Promise<Event> {
              return prisma.event.create({
                data,
                include: { organizer: true, participants: true }
              });
            }

            static async update(id: string, data: Prisma.EventUpdateInput): Promise<Event> {
              return prisma.event.update({
                where: { id },
                data,
                include: { organizer: true, participants: true }
              });
            }

            static async delete(id: string): Promise<Event> {
              return prisma.event.delete({
                where: { id },
                include: { organizer: true, participants: true }
              });
            }

            static async getParticipantsCount(id: string): Promise<number> {
              return prisma.eventRegistration.count({
                where: { eventId: id }
              });
            }
          }
        </code>
      </template>
    </pattern>
  </database_patterns>

  <component_patterns>
    <pattern name="form_component">
      <description>Reusable form component with validation</description>
      <template>
        <code language="typescript">
          // components/forms/event-form.tsx
          'use client';

          import { useState } from 'react';
          import { useForm } from 'react-hook-form';
          import { zodResolver } from '@hookform/resolvers/zod';
          import { z } from 'zod';
          import { Button } from '@/components/ui/button';
          import { Input } from '@/components/ui/input';
          import { Textarea } from '@/components/ui/textarea';
          import { Label } from '@/components/ui/label';

          const eventFormSchema = z.object({
            title: z.string().min(1, 'Title is required').max(100),
            description: z.string().max(500, 'Description too long'),
            date: z.string().min(1, 'Date is required'),
            location: z.string().min(1, 'Location is required'),
            maxParticipants: z.number().min(1).max(100)
          });

          type EventFormData = z.infer<typeof eventFormSchema>;

          interface EventFormProps {
            initialData?: Partial<EventFormData>;
            onSubmit: (data: EventFormData) => Promise<void>;
            onCancel: () => void;
            isLoading?: boolean;
          }

          export function EventForm({
            initialData,
            onSubmit,
            onCancel,
            isLoading = false
          }: EventFormProps) {
            const {
              register,
              handleSubmit,
              formState: { errors }
            } = useForm<EventFormData>({
              resolver: zodResolver(eventFormSchema),
              defaultValues: initialData
            });

            return (
              <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
                <div>
                  <Label htmlFor="title">Title</Label>
                  <Input
                    id="title"
                    {...register('title')}
                    placeholder="Enter event title"
                  />
                  {errors.title && (
                    <p className="text-sm text-red-600">{errors.title.message}</p>
                  )}
                </div>

                <div>
                  <Label htmlFor="description">Description</Label>
                  <Textarea
                    id="description"
                    {...register('description')}
                    placeholder="Describe the event"
                    rows={3}
                  />
                  {errors.description && (
                    <p className="text-sm text-red-600">{errors.description.message}</p>
                  )}
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="date">Date</Label>
                    <Input
                      id="date"
                      type="datetime-local"
                      {...register('date')}
                    />
                    {errors.date && (
                      <p className="text-sm text-red-600">{errors.date.message}</p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="maxParticipants">Max Participants</Label>
                    <Input
                      id="maxParticipants"
                      type="number"
                      {...register('maxParticipants', { valueAsNumber: true })}
                    />
                    {errors.maxParticipants && (
                      <p className="text-sm text-red-600">{errors.maxParticipants.message}</p>
                    )}
                  </div>
                </div>

                <div>
                  <Label htmlFor="location">Location</Label>
                  <Input
                    id="location"
                    {...register('location')}
                    placeholder="Event location"
                  />
                  {errors.location && (
                    <p className="text-sm text-red-600">{errors.location.message}</p>
                  )}
                </div>

                <div className="flex gap-2">
                  <Button type="submit" disabled={isLoading}>
                    {isLoading ? 'Saving...' : 'Save Event'}
                  </Button>
                  <Button type="button" variant="outline" onClick={onCancel}>
                    Cancel
                  </Button>
                </div>
              </form>
            );
          }
        </code>
      </template>
    </pattern>

    <pattern name="data_loading_component">
      <description>Component with loading states and error handling</description>
      <template>
        <code language="typescript">
          // components/event-list.tsx
          'use client';

          import { useEffect, useState } from 'react';
          import { EventCard } from '@/components/event-card';
          import { Skeleton } from '@/components/ui/skeleton';
          import { Alert, AlertDescription } from '@/components/ui/alert';

          interface Event {
            id: string;
            title: string;
            date: string;
            location: string;
            organizer: { name: string };
          }

          export function EventList() {
            const [events, setEvents] = useState<Event[]>([]);
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState<string | null>(null);

            useEffect(() => {
              async function fetchEvents() {
                try {
                  setIsLoading(true);
                  const response = await fetch('/api/events');

                  if (!response.ok) {
                    throw new Error('Failed to fetch events');
                  }

                  const data = await response.json();
                  setEvents(data.events);
                } catch (err) {
                  setError(err instanceof Error ? err.message : 'An error occurred');
                } finally {
                  setIsLoading(false);
                }
              }

              fetchEvents();
            }, []);

            if (error) {
              return (
                <Alert variant="destructive">
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              );
            }

            if (isLoading) {
              return (
                <div className="space-y-4">
                  {Array.from({ length: 3 }).map((_, i) => (
                    <Skeleton key={i} className="h-32 w-full" />
                  ))}
                </div>
              );
            }

            if (events.length === 0) {
              return (
                <Alert>
                  <AlertDescription>No events found.</AlertDescription>
                </Alert>
              );
            }

            return (
              <div className="space-y-4">
                {events.map((event) => (
                  <EventCard key={event.id} event={event} />
                ))}
              </div>
            );
          }
        </code>
      </template>
    </pattern>
  </component_patterns>

  <testing_patterns>
    <pattern name="unit_test_template">
      <description>Standard unit test structure for components</description>
      <template>
        <code language="typescript">
          // components/__tests__/event-form.test.tsx
          import { render, screen, fireEvent, waitFor } from '@testing-library/react';
          import userEvent from '@testing-library/user-event';
          import { EventForm } from '../event-form';

          const mockOnSubmit = jest.fn();
          const mockOnCancel = jest.fn();

          describe('EventForm', () => {
            beforeEach(() => {
              jest.clearAllMocks();
            });

            it('renders form fields correctly', () => {
              render(
                <EventForm
                  onSubmit={mockOnSubmit}
                  onCancel={mockOnCancel}
                />
              );

              expect(screen.getByLabelText(/title/i)).toBeInTheDocument();
              expect(screen.getByLabelText(/description/i)).toBeInTheDocument();
              expect(screen.getByLabelText(/date/i)).toBeInTheDocument();
              expect(screen.getByLabelText(/location/i)).toBeInTheDocument();
              expect(screen.getByLabelText(/max participants/i)).toBeInTheDocument();
            });

            it('shows validation errors for empty required fields', async () => {
              const user = userEvent.setup();
              render(
                <EventForm
                  onSubmit={mockOnSubmit}
                  onCancel={mockOnCancel}
                />
              );

              const submitButton = screen.getByRole('button', { name: /save event/i });
              await user.click(submitButton);

              await waitFor(() => {
                expect(screen.getByText('Title is required')).toBeInTheDocument();
                expect(screen.getByText('Date is required')).toBeInTheDocument();
                expect(screen.getByText('Location is required')).toBeInTheDocument();
              });

              expect(mockOnSubmit).not.toHaveBeenCalled();
            });

            it('submits form with valid data', async () => {
              const user = userEvent.setup();
              render(
                <EventForm
                  onSubmit={mockOnSubmit}
                  onCancel={mockOnCancel}
                />
              );

              await user.type(screen.getByLabelText(/title/i), 'Test Event');
              await user.type(screen.getByLabelText(/description/i), 'Test Description');
              await user.type(screen.getByLabelText(/location/i), 'Test Location');
              await user.type(screen.getByLabelText(/max participants/i), '10');

              const submitButton = screen.getByRole('button', { name: /save event/i });
              await user.click(submitButton);

              await waitFor(() => {
                expect(mockOnSubmit).toHaveBeenCalledWith({
                  title: 'Test Event',
                  description: 'Test Description',
                  date: '',
                  location: 'Test Location',
                  maxParticipants: 10
                });
              });
            });

            it('calls onCancel when cancel button is clicked', async () => {
              const user = userEvent.setup();
              render(
                <EventForm
                  onSubmit={mockOnSubmit}
                  onCancel={mockOnCancel}
                />
              );

              const cancelButton = screen.getByRole('button', { name: /cancel/i });
              await user.click(cancelButton);

              expect(mockOnCancel).toHaveBeenCalledTimes(1);
            });
          });
        </code>
      </template>
    </pattern>

    <pattern name="api_integration_test">
      <description>Integration test for API routes</description>
      <template>
        <code language="typescript">
          // tests/integration/api/events.test.ts
          import { createMocks } from 'node-mocks-http';
          import { POST } from '@/app/api/events/route';
          import { prisma } from '@/lib/prisma';

          // Mock Prisma
          jest.mock('@/lib/prisma', () => ({
            prisma: {
              event: {
                create: jest.fn(),
                findMany: jest.fn(),
                findUnique: jest.fn(),
                update: jest.fn(),
                delete: jest.fn()
              }
            }
          }));

          describe('/api/events', () => {
            beforeEach(() => {
              jest.clearAllMocks();
            });

            describe('POST /api/events', () => {
              it('creates a new event successfully', async () => {
                const mockEvent = {
                  id: '1',
                  title: 'Test Event',
                  description: 'Test Description',
                  date: '2024-01-01T10:00:00Z',
                  location: 'Test Location',
                  maxParticipants: 10,
                  organizerId: 'user-1'
                };

                const mockPrisma = prisma as jest.Mocked<typeof prisma>;
                mockPrisma.event.create.mockResolvedValue(mockEvent);

                const { req, res } = createMocks({
                  method: 'POST',
                  url: '/api/events',
                  body: {
                    title: 'Test Event',
                    description: 'Test Description',
                    date: '2024-01-01T10:00:00Z',
                    location: 'Test Location',
                    maxParticipants: 10
                  },
                  headers: {
                    'x-user-id': 'user-1'
                  }
                });

                await POST(req, res);

                expect(res._getStatusCode()).toBe(201);
                const data = JSON.parse(res._getData());
                expect(data).toMatchObject({
                  id: '1',
                  title: 'Test Event'
                });

                expect(mockPrisma.event.create).toHaveBeenCalledWith({
                  data: expect.objectContaining({
                    title: 'Test Event',
                    organizerId: 'user-1'
                  }),
                  include: { organizer: true }
                });
              });

              it('returns 400 for invalid data', async () => {
                const { req, res } = createMocks({
                  method: 'POST',
                  url: '/api/events',
                  body: {
                    title: '', // Invalid: empty title
                    date: 'invalid-date'
                  }
                });

                await POST(req, res);

                expect(res._getStatusCode()).toBe(400);
                const data = JSON.parse(res._getData());
                expect(data.error).toBe('Invalid input');
              });

              it('returns 401 without user ID', async () => {
                const { req, res } = createMocks({
                  method: 'POST',
                  url: '/api/events',
                  body: {
                    title: 'Test Event',
                    date: '2024-01-01T10:00:00Z',
                    location: 'Test Location',
                    maxParticipants: 10
                  }
                  // No x-user-id header
                });

                await POST(req, res);

                expect(res._getStatusCode()).toBe(401);
                const data = JSON.parse(res._getData());
                expect(data.error).toBe('Unauthorized');
              });
            });
          });
        </code>
      </template>
    </pattern>
  </testing_patterns>
</gamenight_common_patterns>